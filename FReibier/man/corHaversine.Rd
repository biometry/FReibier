% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/corHaversine.R
\name{corHaversine}
\alias{corHaversine}
\title{Great-circle distance constructor for use as corStruct in nlme}
\usage{
corHaversine(value = numeric(0), form = ~1, mimic = "corSpher",
  nugget = FALSE, fixed = FALSE)
}
\arguments{
\item{value}{Optional values to be used as parameter in the correlation structure computation (e.g. nugget and range). Defaults to 0.}

\item{form}{One-sided formula to represent the variables from which to compute the great-circle distance}

\item{mimic}{Name of the correlation structure, e.g. "corExp" etc; defaults to "corSpher"}

\item{nugget}{Logical; should a nugget be fitted? Defaults to FALSE.}

\item{fixed}{Logical; should the parameter(s) be estimated? (If not, they must be provided as argument to \option{value}.) Defaults to FALSE.}
}
\value{
An internal constructor function to be called within \code{gls} or \code{(n)lme}.
}
\description{
Compute great-circle distances from latitude/longitude coordinates in nlme
}
\details{
The currently implemented \code{corStruct} functions in \pkg{nlme} do not allow for an inclusion of latitude/longitude as coordinates, as distances are computed as Euclidean. This function can be used to achieve a correct orthodromic distance representation for use in spatial correlation structures. The code is taken from an answer by Nate Pope on StackOverflow \url{https://stackoverflow.com/questions/18857443/specifying-a-correlation-structure-for-a-linear-mixed-model-using-the-ramps-pack}.
}
\examples{
library(MASS)
set.seed(1001)
sample_data <- data.frame(lon = -121:-22, lat = -50:49)
ran <- 1000 # 'range' parameter for spherical correlation
dist_matrix <- as.matrix(haversineDist(sample_data))    # haversine distance matrix
# set up correlation matrix of response
corr_matrix <- 1-1.5*(dist_matrix/ran)+0.5*(dist_matrix/ran)^3
corr_matrix[dist_matrix > ran] = 0
diag(corr_matrix) <- 1
# set up covariance matrix of response
sigma <- 2  # residual standard deviation
cov_matrix <- (diag(100)*sigma) \%*\% corr_matrix \%*\% (diag(100)*sigma)   # correlated response
# generate response
sample_data$y <- mvrnorm(1, mu = rep(0, 100), Sigma = cov_matrix)

# fit model
gls_haversine <- gls(y ~ 1, correlation = corHaversine(form=~lon+lat, mimic="corSpher"), data = sample_data)
summary(gls_haversine)

}
\seealso{
\code{nlme::corExp}
}
\author{
Nate Pope; (copy-pasted into R by Carsten F. Dormann <carsten.dormann@biom.uni-freiburg.de>)
}
