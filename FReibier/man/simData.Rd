% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simData.R
\name{simData}
\alias{simData}
\title{Simulate spatially autocorrelated (SAC) data}
\usage{
simData(dataset,
        filename = "default",
        gridsize = c(50L, 50L),
        cvfold = 10L,
        cvblock.size = c(10,10),
        r.seed = 20151126,
        n.predictor = 7L,
        f.smooth = list(function() lon,
                        function() lat,
                        function() (lon - mean(lon))^2,
                        function() (lat - mean(lat))^2,
                        function() x3^x4 * x4^x3,
                        function() x1^x1 * x3^x4,
                        function() x2^x1 * x4^x3 * log(x5 + 1)),
        f.realistic = list(var = 0.1, scale = 0.1),
        f.real = list(resolution = 10L,
                      extent = c("5N24E", "7S37E"),
                      bio.vars = c("bio1", "bio19", "bio2", "bio12", "bio4", "bio18", "bio3")),
        f.response = c("x1", "x4", "x4^2", "x3*x4", "x3"),
        par.response = "default", 
        f.sac1 = list(corCoef = -3,
                      sarFactor = 1),
        f.sac2 = "x1", 
        f.sac3 = c("^","*"), 
        f.sac4 = list(dispersal.max = 0.1, 
                      dispersal.shape = 30),
        interactive = TRUE)
}
\arguments{
\item{dataset}{Input character of the form \code{"abc"}, with:
\describe{
   \item{\code{a}}{predictor landscape: \describe{
     \item{1}{smooth (linear and non-linear gradients without noise)}
     \item{2}{realistic (unconditional Gaussian random fields from exponential covariance models)}
     \item{3}{real (Real bio-climatic predictors from \url{http://www.worldclim.org})}
     }}
   \item{\code{b}}{distribution of the response variable: \describe{
     \item{1}{Gaussian}
     \item{2}{Bernoulli}
     \item{3}{zero-inflated Poisson}
     }}
   \item{\code{c}}{SAC scenario: \describe{
     \item{0}{Reference, i.e. no SAC}
     \item{1}{SAC onto response variable}
     \item{2}{Omitted predictor}
     \item{3}{Wrong functional form, e.g. intentionally miss quadratic term or interaction}
     \item{4}{Dispersal}
     }}
}}

\item{filename}{The destination file name (character). Defaults to "dataset\code{dataset}", e.g. "dataset110".}

\item{gridsize}{Vector defining [1] the number of cells in x direction (Longitude), and [2] the number of cells in y direction (Latitude).}

\item{cvfold}{Number of unique Cross-Validation (CV) IDs to be assigned blockwise to the data.}

\item{cvblock.size}{Number of cells in x, y direction in one CV block.}

\item{r.seed}{Randomisation value to be used in \code{\link[base]{set.seed}} before any stochastic process. Defaults to \code{20151126}}

\item{n.predictor}{Number of predictors to be simulated.}

\item{f.smooth}{If \code{dataset = "1**"}: List of \code{n.predictor} linear and non-linear functions. Can be functions of Longitude (\code{lon}) and/or Latitude (\code{lat}).}

\item{f.realistic}{If \code{dataset = "2**"}: A list of \code{var} and \code{scale}, which are passed to \code{\link[RandomFields]{RMexp}} to compute the exponential covariance model. If both arguments are of length \code{n.predictor} a new model is computed for every predictor.}

\item{f.real}{If \code{dataset = "3**"}: A list comprising: 
\itemize{
 \item \code{resolution} [minutes of a degree] = 2.5, 5, and 10 (default). Defines the resoultion of the global interpolated climate data from \url{http://www.worldclim.org}; 
 \item \code{extent} = numeric vector of two geogr. coordinates (diagonal corners).
 \item \code{bio.vars} = character string of length \code{n.predictor} defining which bioclimatic should variables be used.
}}

\item{f.response}{Character string of mathematical terms (based on predictors x1, x2,...) yielding the response varibale.}

\item{par.response}{Coefficients for the elements in f.response. By default this numeric vector contains an intercept (first element) and beta values for every element in f.response. If the distribution is set to Gaussian, an addtional (last) element is provided to set the standard deviation in \code{\link[stats]{rnorm}}. 
Defaults to 
\itemize{
 \item Gaussian: 0.8 (intercept), 0.2, 0.9, -0.8, -0.6, 0.5, 0.2 (Gaussian error)
 \item Bernoulli: 0.2 (intercept), 4.5, -1.2, -1.2, -1.1, 0.9
 \item Poisson: 0.2 (intercept), 1.6, 0.9, 0.8, -0.8, 0.5  
}
\strong{Please note:} Poisson is zero-inflated and therefore requires a list of two numeric parameter vectors. First item is a numeric vector setting the Bernoulli coefficients, second the Poisson coefficients.}

\item{f.sac1}{If \code{dataset = "**1"}: List of \code{corCoef}, a coefficient impacting the correlation structure, and (only if \code{dataset = "*11"}) \code{sarFactor}, a factor determining the magnitude of SAC added to the existing response varibale.}

\item{f.sac2}{If \code{dataset = "**2"}: Name of the predictor(s) to be omitted in the model structure.}

\item{f.sac3}{If \code{dataset = "**3"}: Character string of "^" and/or "*" to filter (\code{\link[base]{grep}}) and omit respective terms in the model structure.}

\item{f.sac4}{If \code{dataset = "**4"}: A list of \code{dispersal.max} = maximum dispersal factor, and \code{dispersal.shape} = shape factor, the higher the more skewed the exponential curve.}

\item{interactive}{Defaults to \code{TRUE}. If \code{FALSE} existing files are overwritten and data (if not existiing) downloaded automatically, i.e. without asking.}
}
\value{
No R output. Data and instruction is saved to netCDF file (\code{filename.nc}).
}
\description{
Use this function to simulate data on three different landscapes; a Gaussian, Bernoulli or zero-inflated Poisson distributed repsonse variable; and four different causes of SAC or reference data, i.e. no SAC.
}
\details{
Designed to run in default mode. 
         
         The cell values in the case of the \strong{\code{realistic} predictor landscape} are simulated (with \code{\link[RandomFields]{RFsimulate}}) based on a stationary isotropic covariance model. Because the covariance function (\eqn{C(r)=e^{-r}}) largely (by default: only) depends on the distance between two points the resulting predictor landscape becomes spatially autocorrelated. 
         (Please note: We modify the convariance function by altering \code{var} (additional variance argument), and \code{scale} (additional scale argument) in \code{f.realistic}.)
}
\note{
\itemize{
\item SAC cause 1, i.e. spatial error onto response (\code{dataset = "**1"}), is computationally burdensome because of the inversion of the distance matrix. This can be severe for large grids, i.e. \code{gridsize > c(100,100)}.
\item It may be necessary to change the parameter settings (\code{par.response}) for SAC cause 3. Particularly in the case of a Bernoully distributed response variable the magnitude of SAC is rather sensitive to the \code{par.response} values.
}
}
\examples{
\dontrun{

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-# 
# example structure                           #
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# landscape, distribution, SAC cause

# simulate data with simData

# extract data with extract.ncdf
# lattice::levelplot of the response variable

# build linear model: model structure in attributes of netCDF file

# compute residulas
# Uni- and multivariate spatial correlograms with ncf::correlog
# plot correlogram to check spatial autocorrelation

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# 12 datasets with different settings         #
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

library(lattice)
library(ncf)
#---------------------------------------------#
# smooth landscape, Gaussian distribution, refrence data

simData("110")

d110 <- extract.ncdf("dataset110.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d110) # levelplot response

fm110 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d110, family = "gaussian")
summary(fm110) 
res110 <- residuals(fm110) # calculate residuals
co110 <- correlog(d110$Lat, d110$Lon, res110, increment=0.02, resamp=1) # check autocorrleation
plot(co110$mean.of.class, co110$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset110")

#---------------------------------------------#
# smooth landscape, Gaussian distribution, SAC onto response

simData("111")

d111 <- extract.ncdf("dataset111.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d111) # levelplot response

fm111 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d111, family = "gaussian")   
summary(fm111) 
res111 <- residuals(fm111) # calculate residuals
co111 <- correlog(d111$Lat, d111$Lon, res111, increment=0.02, resamp=1) # check autocorrleation
plot(co111$mean.of.class, co111$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset111")

#---------------------------------------------#
# smooth landscape, Gaussian distribution, omitted predictor

simData("112")

d112 <- extract.ncdf("dataset112.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d112) # levelplot response

fm112 <- glm(y ~ x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d112, family = "gaussian") # omit x1   
summary(fm112) 
res112 <- residuals(fm112) # calculate residuals
co112 <- correlog(d112$Lat, d112$Lon, res112, increment=0.02, resamp=1) # check autocorrleation
plot(co112$mean.of.class, co112$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset112")

#---------------------------------------------#
# smooth landscape, Bernoulli distribution, refrence data

simData("120")

d120 <- extract.ncdf("dataset120.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d120) # levelplot response

fm120 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d120, family = "gaussian")   
summary(fm120) 
res120 <- residuals(fm120) # calculate residuals
co120 <- correlog(d120$Lat, d120$Lon, res120, increment=0.02, resamp=1) # check autocorrleation
plot(co120$mean.of.class, co120$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset120")

#---------------------------------------------#
# smooth landscape, Bernoulli distribution, SAC onto response

simData("121")

d121 <- extract.ncdf("dataset121.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d121) # levelplot response

fm121 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d121, family = "gaussian")   
summary(fm121) 
res121 <- residuals(fm121) # calculate residuals
co121 <- correlog(d121$Lat, d121$Lon, res121, increment=0.02, resamp=1) # check autocorrleation
plot(co121$mean.of.class, co121$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset121")

#---------------------------------------------#

simData("122")

d122 <- extract.ncdf("dataset122.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d122) # levelplot response

fm122 <- glm(y ~ x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d122, family = "gaussian") # omit x1   
summary(fm122) 
res122 <- residuals(fm122) # calculate residuals
co122 <- correlog(d122$Lat, d122$Lon, res122, increment=0.02, resamp=1) # check autocorrleation
plot(co122$mean.of.class, co122$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset122")

#---------------------------------------------#
# real landscape, Gaussian distribution, refrence data

simData("310")

d310 <- extract.ncdf("dataset310.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d310) # levelplot response

fm310 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d310, family = "gaussian")   
summary(fm310) 
res310 <- residuals(fm310) # calculate residuals
co310 <- correlog(d310$Lat, d310$Lon, res310, increment=0.16, resamp=1) # check autocorrleation
plot(co310$mean.of.class, co310$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset310")

#---------------------------------------------#
# real landscape, Gaussian distribution, SAC onto response

simData("311")

d311 <- extract.ncdf("dataset311.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d311) # levelplot response

fm311 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d311, family = "gaussian")   
summary(fm311) 
res311 <- residuals(fm311) # calculate residuals
co311 <- correlog(d311$Lat, d311$Lon, res311, increment=0.16, resamp=1) # check autocorrleation
plot(co311$mean.of.class, co311$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset311")

#---------------------------------------------#
# real landscape, Gaussian distribution, omitted predictor

simData("312")

d312 <- extract.ncdf("dataset312.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d312) # levelplot response

fm312 <- glm(y ~ x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d312, family = "gaussian") # omit x1   
summary(fm312) 
res312 <- residuals(fm312) # calculate residuals
co312 <- correlog(d312$Lat, d312$Lon, res312, increment=0.16, resamp=1) # check autocorrleation
plot(co312$mean.of.class, co312$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset312")

#---------------------------------------------#
# real landscape, Bernoulli distribution, refrence data

simData("320")

d320 <- extract.ncdf("dataset320.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d320) # levelplot response

fm320 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d320, family = "gaussian")   
summary(fm320) 
res320 <- residuals(fm320) # calculate residuals
co320 <- correlog(d320$Lat, d320$Lon, res320, increment=0.16, resamp=1) # check autocorrleation
plot(co320$mean.of.class, co320$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset320")

#---------------------------------------------#
# real landscape, Bernoulli distribution, SAC onto response

simData("321")

d321 <- extract.ncdf("dataset321.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d321) # levelplot response

fm321 <- glm(y ~ x1 + x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d321, family = "gaussian")   
summary(fm321) 
res321 <- residuals(fm321) # calculate residuals
co321 <- correlog(d321$Lat, d321$Lon, res321, increment=0.16, resamp=1) # check autocorrleation
plot(co321$mean.of.class, co321$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset321")

#---------------------------------------------#
# real landscape, Bernoulli distribution, omitted predictor

simData("322")

d322 <- extract.ncdf("dataset322.nc")[[2]] # extract data
levelplot(y~Lon+Lat,data=d322) # levelplot response

fm322 <- glm(y ~ x4 + I(x4^2) + x3*x4 + x3 + x2 + x5 + x6 + x7, 
             data = d322, family = "gaussian") # omit x1   
summary(fm322) 
res322 <- residuals(fm322) # calculate residuals
co322 <- correlog(d322$Lat, d322$Lon, res322, increment=0.16, resamp=1) # check autocorrleation
plot(co322$mean.of.class, co322$correlation, type = "o", ylim = c(-1,1), # plot correlogram
     ylab="Moran Similarity", xlab="averaged distance class", main = "dataset322")
}
}
\seealso{
\code{\link{extract.ncdf}} which allows you to readily extract data and attributes from the netCDF file.
}
\author{
Severin Hauenstein <severin.hauenstein@biom.uni-freiburg.de>
}
